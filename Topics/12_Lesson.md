# ROS и мой первый пакет 

## Содержание

- [ROS и мой первый пакет](#ros-и-мой-первый-пакет)
  - [Содержание](#содержание)
  - [Что нужно, чтобы начать?](#что-нужно-чтобы-начать)
  - [Основная информация](#основная-информация)
    - [Подготовка рабочего пространства (workspace -\> ws)](#подготовка-рабочего-пространства-workspace---ws)
      - [Добавить подключение рабочего пространства в сессию терминала](#добавить-подключение-рабочего-пространства-в-сессию-терминала)
    - [Проверка установки](#проверка-установки)
    - [Пространство готово - теперь создаем пакет](#пространство-готово---теперь-создаем-пакет)
    - [Сборка пакета](#сборка-пакета)
    - [Разместим новый пакет в репозиторий на GitHub](#разместим-новый-пакет-в-репозиторий-на-github)
    - [Первый узел](#первый-узел)
    - [Залить наработки в конце работы](#залить-наработки-в-конце-работы)
  - [Пора двигаться!](#пора-двигаться)
  - [Научим робота видеть!](#научим-робота-видеть)
  - [Робот, который смог (двигаться к цели)!](#робот-который-смог-двигаться-к-цели)

## Что нужно, чтобы начать?

- Установленная [Ubuntu 20.04 LTS](https://releases.ubuntu.com/20.04/)
- Установленный [ROS Noetic](https://wiki.ros.org/noetic/Installation/Ubuntu)
- Установленный пакет `git`
- Созданный аккаунт на GitHub

## Основная информация

Работы с ROS начинается с того, что нужно понять концепцию организации кода и файлов. Главный аспект строится хранении кода в **пакетах**.

> **Пакет** - это набор файлов, объединенных единым смыслом или задачей. Например, пакет драйвера для камеры, пакет для подключения джойстика, пакет колесного робота и т.д.

Пакетов в интернете очень много, но чтобы работать и разрабатывать свои пакеты, нужно создать **рабочее пространство для разработки**. Этим и займемся!

### Подготовка рабочего пространства (workspace -> ws)

> Для работы с собственным рабочим пространством (использование утилит `catkin_make` и др.) должно быть подключено системное рабочее пространство. Как это сделать есть в разделе [FAQ](../FAQ.md), но также все тонкости можно прояснить на практике или задав вопрос преподавателю!

Так как ROS видит пакеты только в рабочем пространстве, то необходимо создать собственный ws для работы с ним. Можно подглядеть в [исходную инфу на офф сайте](http://wiki.ros.org/catkin/Tutorials/create_a_workspace), а можно сделать следующие шаги:

Во-первых, создаем папку, которая будет нашим ws. Назовем ее `catkin_ws`:

```bash
mkdir -p ~/catkin_ws/src
```

> Опция `-p` указывает, что нужно создать полный путь, даже если каких-то папок в пути нет.

В нашем случае папки `catkin_ws` нет, так что создаем весь путь с опцией `-p`. `src` папку внутри надо создавать, чтобы потом туда размещать исходные коды. Делаем два действия одной командой =)

После этого переходим в корень ws и вызываем утилиту сборки (так нужно в первый раз инициализировать ws):

```bash
cd ~/catkin_ws
catkin_make
```

Рабочее пространство готово и осталось добавить в файл `~/.bashrc` строку для автоматической настройки ROS на подключение нашего ws:

#### Добавить подключение рабочего пространства в сессию терминала

```bash
source ~/catkin_ws/devel/setup.bash
```

Сделать это можно как и с системным ws:

```bash
echo "source ~/catkin_ws/devel/setup.bash" >> ~/.bashrc
```

Или открыть файл `~/.bashrc` и прописать ручками.

> Система ROS может видеть только одно рабочее простанство, создание нескольких пространств и добавление в `rc`-файл не даст результата

### Проверка установки

После перезапуска терминалов (для настройки сессий) можно проверить установку всех ws

```bash
echo $ROS_PACKAGE_PATH
```

В результате должен появиться путь до созданного рабочего простанства, а также путь до системного рабочего пространства. То есть, строка должна содержать результат, похожий на вот это:

```bash
/home/user/catkin_ws/src:/opt/ros/noetic/share
```

> Часто переменные окружения содержат список путей. А разделителем списка является символ '`:`'.

Как видно, первый путь является путем до нового ws, а второй - до системного.

### Пространство готово - теперь создаем пакет

Вся экосистема ROS основывается на концепции пакетов, которые включают различные компоненты. В этом топике мы знакомимся с возможностями создания пакетов, их редактирования, а также c инструментом сборки, который будет использоваться далее. Можно также подглядеть на [оф страницу =)](http://wiki.ros.org/ROS/Tutorials/CreatingPackage).

Для начала перейдем в наш ws, в директорию `src`:

```bash
cd ~/catkin_ws/src
```

Для создания пакета используется команда:

```bash
catkin_create_pkg [pkg_name] [dep1 dep2 ...]
```

В данной команде первым аргументом передается имя нового пакета, после перечисляются зависимости данного пакета.

> Квадратные скобки указывают, что это аргументы команды и при подставлении своих значений квадратные скобки не нужны!

Для начала создадим пакет и добавим поддержку библиотек python (rospy):

```bash
catkin_create_pkg study_pkg rospy
```

Далее наблюдаем созданную папку `study_pkg` и два главных файла внутри: `CMakeLists.txt` и `package.xml`

> Создайте пакет `super_name_study_pkg` и просмотрите файлы `CMakeLists.txt` и `package.xml`. Вместо "name" поставьте свое имя или фамилию (или как-то по-другому сделайте название пакета уникальным). Не забудьте, что на компьютере могут работать другие люди и ставить свои пакеты!
> Мы дальше будем использовать имя пакета `study_pkg`, а тебе надо заменять его на свой =)

В содержании `package.xml` можно выделить основные блоки:  

Заголовок, в нем содержится основная инфа о пакете

```xml
<?xml version="1.0"?>
<package format="2">
  <name>study_pkg</name>
  <version>0.0.0</version>
  <description>The study_pkg package</description>
  <maintainer email="user@todo.todo">user</maintainer>
  <license>TODO</license>
```

Зависимости (инструмент сборки, сборка, экспорт, runtime (exec) - выполнение)

```xml
  <buildtool_depend>catkin</buildtool_depend>
  <build_depend>roscpp</build_depend>
  <build_depend>rospy</build_depend>
  <build_export_depend>roscpp</build_export_depend>
  <build_export_depend>rospy</build_export_depend>
  <exec_depend>roscpp</exec_depend>
  <exec_depend>rospy</exec_depend>
```

Остальное можно также наблюдать внутри комметариев формата xml. Там также приведены некоторые описания строк и блоков.

Внутри `CMakeLists.txt` можно также видеть много закомментированных блоков, но в основном можно вытащить базовые куски на момент инициализации:  

Определение минимальной версии сборки `cmake` и название проекта

```cmake
cmake_minimum_required(VERSION 3.0.2)
project(study_pkg)
```

Поиск и подключение зависимостей

```cmake
find_package(catkin REQUIRED COMPONENTS
  rospy
)
```

Также создается базовая папка `src` для файлов исходных текстов.  

### Сборка пакета

А теперь сделаем пакет видимым системе ROS - для этого надо просто вызвать сборку в корне рабочего пространства. Перейдите в папку рабочего пространства:

```bash
cd ~/catkin_ws
```

и выполните команду сборки:

```bash
catkin_make
```

После успешного выполнения сборки убедимся в том, что экосистема ROS видит наш пакет! Перезапустите терминал (или вызовите `source ~/.bashrc`) и проверяйте список пакетов в системе:

```bash
rospack list
```

В списке должна быть строка:

```bash
...
study_pkg /home/user/catkin_ws/src/study_pkg
...
```

С помощью команды `rospack help` можно получить информацию об утилите и ее аргументах.

> Вообще рекомендую не забывать этот аргумент `help` (или опцию `-h`), так как он применим ко всем утилитам ROS экосистемы.

### Разместим новый пакет в репозиторий на GitHub

Для начала необходимо создать новый репозиторий на [github.com](https://github.com/) в своем аккаунте. Если чего-то не хватает - разбираемся вместе или по инструкциям из веба, их благо достаточно. Обязательно установите опцию "Add a README file", чтобы репозиторий не был пустым!

> Можно глянуть как [инициализировать git с дальнейшими действиями](https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/).

После каждой команды `git *` рекомендую выполнять `git status`, чтобы видеть результат действий

Теперь перейдем в папку пакета `study_pkg`:

```bash
roscd study_pkg
```

Инициализируем папку как локальный git репозиторий и переключимся на ветку main (по новым правилам GitHub):

```bash
git init
git checkout -b main
```

Результат

```console
Initialized empty Git repository in /home/user/catkin_ws/src/study_pkg/.git/
```

Посмотрите состояние свежего репозитория командой:

```bash
git status
```

Теперь надо привязать локальный репозиторий к удаленному:

```bash
git remote add origin [Repo URL]
```

Repo URL - путь удаленного репозитория, берется со страницы репозитория из зеленой кнопки "Clone or download".
Например, для репозитория курса была использована следующая команда:

```bash
git remote add origin https://github.com/user/super_user_study_pkg.git
```

Как видно, в URL содержится имя владельца репозитория и его названия.

Настроим, чтобы ветка `main` локального репозитория следила за веткой `main` удаленного репозитория, для этого стянем все данные с ветки `main` удаленного репозитория (который при соединении в предыдущей команде мы назвали `origin`):

```bash
git pull origin main
```

> На удаленном репозитории ветка `main` называется `origin/main`

После этого можно учесть (индексировать) новые файлы пакета:

```bash
git add -A
```

> Опция `-A` добавляет все неучтенные файлы. Вместо нее можно просто перечислить файлы, которые необходимо добавить к учету в коммитах.

И сделать коммит в локальном репо:

```bash
git commit -am "First package commit"
```

> Опция `-a` делает `git add` ко всем изменениям учтенных (индексированных) файлов - упрощает нам задачу.

> Опция `-m` устанавливает коммент к коммиту. Коммент пишется после опции.

> ❔ Если гит не хочет делать коммит и пишет просьбу указать "Ты кто такой?" (почта и имя), глянь в [FAQ раздел](../FAQ.md#я-делаю-git-commit-а-он-хочет-e-mail-и-имя), он не любит работать с незнакомцами 😝

После остается только закинуть все сделанные коммиты (а их пока один штука) на удаленный репо:

```bash
git push --set-upstream origin main
```

> Для выполнения данной команды может потребоваться ввод имя пользователя и пароль (токен, инфа есть в [FAQ](../FAQ.md#как-делать-git-push-с-паролем)).

И все! Можно смотреть на результаты на сайте!

### Первый узел

Мы же тут не просто пакеты создавать собрались? Пора прогать! Да, это будет Hello World, но не просто программа, а целый узел!

Суть в том, что все программы в ROS называются узлами. Это как в графе, где узлы графа соединены ребрами. Так вот мы в будущем узнаем, что узлы действительно соединяются в ROS, но в качестве ребер выступают каналы связи!

Но сегодня наша цель - написать первый просто узел =) Начнем!

В Python есть разделение `.py` файлов на модули исходных кодов и модули исполняемых программ. Отличие простое - первые нужны для хранения логики программ, а вторые для описания процесса запуска программ.

Для исполняемых программ внутри пакета сделайте директорию `scripts` и в ней создайте файл `first_node.py`:

```bash
roscd study_pkg
mkdir scripts
touch scripts/first_node.py
```

После этого открываем любимый редактор и пишем в файле простой кусочек кода:

```python
def main():
    print(f"Hello ROS World!")


if __name__ == "__main__":
    main()
```

Отлично, пробуем стартануть с помощью команды `rosrun`, которой надо передать имя пакета и имя скрипта для запуска!

```bash
rosrun study_pkg first_node.py
```

Упс, ошибочка:

```console
[rosrun] Couldn't find executable named first_node below /home/user/catkin_ws/src/study_pkg
```

Что не так? ROS пытается запустить скрипт, но ему не хватает кое-чего!

Когда мы написали код в файле, то это просто текстовый файл, а чтобы запустить этого код, нужно сделать две вещи:

- Дать файлу права на исполнение;
- Прописать интерпретатор, с помощью которого будет запускаться скрипт

Права даются утилитой `chmod`:

```bash
chmod +x scripts/first_node.py
```

А для указания интерпертатор в начало файла первой строкой пропиши следующую строку:

```python
#!/usr/bin/env python3
```

> Эта строка указывает, чтобы запуск файла производился через интерпретатор `python3`.

Ну что, действия сделаны, пора проверить, заработает ли?

```bash
rosrun study_pkg first_node.py
```

И вот результат!

```console
Hello ROS World!
```

Отлично! Получилось, первый пакет с первым узлом готов! Отличное начало!

### Залить наработки в конце работы

После окончания работы на кодом нужно обязательно заливать наработки в репозиторий, чтобы их не потерять и всегда можно было стянуть последнюю версию даже с другой машины!

Нужно добавить новые файлы к индексу:

```bash
git add scripts/first_node.py
```

После этого сделать коммит:

```bash
git commit -am "My first node in ROS, hooray!"
```

> Над комментарием комита можно еще подумать =)

И отправить новые комиты на репозиторий:

```bash
git push
```

> Да-да, теперь без `--set-upstream` опции, так как этот репо уже связан с удаленным


# Робот, покажись!

Теперь начнём знакомиться c роботом Turtlebot в симуляторе Gazebo, давайте запустим нашего робота в симуляторе и увидим, что запустилось всё правильно!

```bash
# TURTLEBOT3_MODEL=waffle - означает установку переменной окружения для запуска данной команды (мы указываем желаемую модель)
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_gazebo turtlebot3_world.launch
```

После выполнения команды должен запуститься симулятор **Gazebo**, в котором будет наш робот:

<p align="center">
<img src=../assets/01_waffle_start.png />
</p>

Вон там снизу справа видишь робота? Это наша вафелька! Если быть точнее, то Turtlebot модели Waffle =)

Попробуй приблизиться с помощью левой, правой клавиш мыши и колёсика (на колёсико ещё можно нажимать) и разглядень поближе:

<p align="center">
<img src=../assets/01_waffle_close_view.png />
</p>

Какая хорошая детализация, не так ли? Красивый робот =)

Полюбуйся ещё минутку на робота, осмотри карту и двигаем дальше!

## Пора двигаться!

Робот в симуляторе - это безопасная зверюшка, с которой можно делать что угодно, даже если и сломается, то перезапуск всё починет!

Чтобы заставить робота двигаться, надо передать роботу команды управления. Сейчас мы его просто запустили, даже немного осмотрели, но ничего не передаём.

Давай запустим команду, которая включит возможность управления роботом с клавиатуры, как мы делали с 2D черепашкой:

> **Симулятор не выключайте!** Делаем это в отдельном окне!

```bash
# Обратите внимание, тут тоже просят модельку задать
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch
```

:muscle: Таакс, настроили окна, положили пальцы на WASD (ещё X для хода назад) и погнали!

<p align="center">
<img src=../assets/01_waffle_keyboard_control.png />
</p>

Отлично! Но подумай, чтобы управлять роботом, нам нужно смотреть сверху, где он находится. Ты в симуляторе смотришь с птичьего вида, а что если нам нужно работать с роботом, которому надо залазить в очень тесные и непролазные места? Нужно научить робота видеть самого!

## Научим робота видеть!

Чтобы дать роботу глаза потребуется две составляющие:

- Датчик, который передаёт информацию об окружающем мире;
- Программа, которая обрабатывает данные с датчика и позволяет воспринимать информацию о дистанции до объектов.

В качестве датчика у нас будет выступать **лидар**! Смотри, где он установлен:

<p align="center">
<img src=../assets/01_waffle_lidar.png />
</p>

Подробности о лидаре узнаешь на лекциях, а пока считаем, что это датчик, который сканирует плоскость и получает информацию о расстояниях до препятствий вокруг (360 градусов).

Отлично! Датчик у нас есть, а теперь давай в третьем терминале запустим программу, которая позволит роботу получать информацию с датчиков и обрабатывать её:

```bash
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_slam turtlebot3_slam.launch
```

<p align="center">
<img src=../assets/01_waffle_mapping.png />
</p>

Если всё запустилось правильно, то запустились программы для получения и обработки данных с лидара. Ты можешь их видеть в интерфейсе программы **rviz**. Rviz - это интерфейс отображения информации в системе робота.

Тут немного разберёмся, в Gazebo виден виртуальный мир симулятора, будто ты смотришь своими глазами, а Rviz - это интерфейс для отображения разной информации, которая есть в роботе! По сути, это взгляд глазами робота. Подумай, своими глазами сверху видишь всю карту, а робот видит только часть, пока никуда не двигался.

Давай посмотрим на информацию пока только с лидара? Отключаем отображение карты, чтобы были видны только робот и данные с лидара:

<p align="center">
<img src=../assets/01_waffle_map_disabled.png />
</p>

Отлично, теперь видно только то, что приходит с лидара без обработки!

Давай попробуем немного поменять наш виртуальный мир и убедиться, что информация с лидара меняется! 

Поставь цилиндр на свою карту с помощью кнопки цилиндра и проверь, как поменялись ваши данные с лидара:

<p align="center">
<img src=../assets/01_waffle_new_object.png />
</p>

Поменялись? Понимаешь, как они меняются, если ставите цилиндр в разных местах?

Попробуй попередвигать/поразворачивать/изменять размер цилиндра с помощью этого меню:

<p align="center">
<img src=../assets/01_gazebo_object_control.png />
</p>

Убедись, что вы понимаете, как меняются данные с лидара. Если нет - двигай ещё =)

:muscle: Небольшое задание, попробуй поменять размер (диаметр) цилиндра так, чтобы он пропал с лидара. Зависит ли диаметр пропадания от расстояния?

Отлично, после небольшого исследования возвращаем карту на место (включаем в rviz). Если мы активно двигали цилиндр, то на карте можно увидеть такие участки:

<p align="center">
<img src=../assets/01_rviz_map_dirty.png />
</p>

Это остатки рабочей системы построения карты в нашей среде. Ведь в Rviz мы только отключили отображение карты, но построение карты работало в фоне всё это время! 

Но не беда, сейчас мы будем катать по карте и в ходе покатушек карта обновится и ложные препятствия пропадут.

:muscle: Упс, я уже немного раскрыл следующее задание.. Ну ничего, поехали, переключаем фокус на терминал с управлением с клавиатуры (если закрыли, не беда, просто включите управление teleop) и твоя задача - построить карту нашей небольшой местности. А если чувствуешь в себе дух гонщика, то попробуй сделать это на скорость!

Представляешь, ты всего лишь с помощью пары команд смог запустить робота в симуляторе и уже катаешь его с помощью своей собственной клавиатуры и строишь карту! Круто, правда?

Но согласись, сегодня дистанционным управлением по кнопкам никого не удивить, давай заставим робота двигаться к цели, учитывая информацию с карты?

## Робот, который смог (двигаться к цели)!

Давай выключим управление teleop и запустим программу, которая будет учитывать карту с данными с лидара и строить 

```bash
TURTLEBOT3_MODEL=waffle roslaunch turtlebot3_navigation move_base.launch
```

Вроде запустили move_base вместо teleop, но ничего не поменялось. Правильно, ведь при управлении с клавиатуры тоже ничего не было видно - робот просто стоял и ждал команды, как ему двигаться.

Теперь, робот не ждёт команды с клавиатуры, а ждёт задания цели, куда ему двигаться. Давайте ему зададим эту цель с помощью кнопки `2D Nav Goal`:

<p align="center">
<img src=../assets/01_rviz_nav_goal.png />
</p>

> Для задания включаете кнопку, левой кнопкой зажимаете в том месте, где хочется остановиться, а затем с зажатой кнопкой управляете направлением постановки.

:muscle: Покатайтесь, посмотрите вид окна gazebo и rviz. Постарайтесь построить полную карту.

Но есть очень важное неудобство, мы не видим маршрута, по которому поедет робот, и цели, куда ему надо ехать. Давайте отобразим эту информацию в rviz!

> Почему именно в rviz? Gazebo - это наш вид из глаз, поэтому мы на нём отобразить информацию не можем. А вот Rviz может отображать информацию, о которой знает робот, поэтому, это самое подходящее место для визуализации!

> Здесь будет без картинки - начинаем привыкать искать подходящие кнопки

В меню Displays (слева в окне) нажимаем `Add`, затем выбираем вкладку `By topic` и ищем путь `/move_base/current_goal`. Выбираем под этим путём строку Pose (с красной стрелкой) и дважды кликаем по ней или снизу нажимаем `OK`.

Отлично, если сейчас задать цель движения, то будет видно, куда он должен двигаться! Круто и очень удобно.

Но ещё, чтобы понимать, как робот поедет, давай отобразим путь робота!

Аналогично переходим в меню выбора отображения (`Add`->`By topic`), выбираем путь `move_base/NavfnROS/plan` и там выбираем Path (зеленая линия). Перед тем, как окончательно выбрать, внизу в Display Name наберите "Global Path".

Отлично, теперь мы видим путь до места, как "планирует" двигаться робот, но зеленый цвет - это очень ярко, поэтому давайте настроим отображение!

В меню Displays найдите Global Path (с зеленой линией), раскройте его, и давайте настраивать:

- Line Style ставим Billboards
- В меню Color выбираем любимый цвет
- В Line Width ставим желаемую толщину линии

Иии, вот так нехитро мы настроили то, как мы хотим видеть информацию внутри робота. Отлично!

Вот так мы научились запускать весь необходимый стек для управления роботом по заданию цели! Поздравляю!

Осталось дело за малым, в следующих темах подробно разобрать, что под этим лежит, чтобы в будущем ты смог сделать своего робота и запустить все необходимое!